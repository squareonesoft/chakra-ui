import { Machine } from "./machine";
import { StateMachine } from "./types";
declare type Extend<C extends {
    value: any;
}> = C & {
    setValue?: (nextValue: C["value"]) => void;
};
export declare const createControllableMachine: <C extends {
    value: any;
}, S extends string, E extends StateMachine.EventObject = StateMachine.AnyEventObject>(config: StateMachine.MachineConfig<Extend<C>, S, E>, opts?: StateMachine.MachineOptions<Extend<C>, E> | undefined) => Machine<Extend<C>, S, E>;
/**
 * Takes a machine that has `value` in its context and makes it controllable
 * by handling `value`, `defaultValue` and `onChange`
 */
export declare const useControllableMachine: <C extends Extend<{
    value: any;
}>, S extends string, E extends StateMachine.EventObject = StateMachine.AnyEventObject>(machine: Machine<C, S, E>, props: Partial<C> & {
    defaultValue?: C["value"] | (() => C["value"]) | undefined;
    onChange?: ((nextValue: C["value"]) => void) | undefined;
}) => readonly [{
    [x: string]: any;
    current: string;
    prev: string;
    event: string | string[];
    context: import("valtio").NonPromise<C>;
    done: boolean;
    matches: (value: string | string[]) => boolean;
    hasTag: (value: string) => boolean;
    nextEvents: string[];
    changed: boolean;
    tags: {
        add: (value: string) => Set<string>;
        clear: () => void;
        delete: (value: string) => boolean;
        forEach: (callbackfn: (value: string, value2: string, set: Set<string>) => void, thisArg?: any) => void;
        has: (value: string) => boolean;
        readonly size: number;
        entries: () => IterableIterator<[string, string]>;
        keys: () => IterableIterator<string>;
        values: () => IterableIterator<string>;
    };
}, (evt: string | StateMachine.AnyEventObject) => void];
export {};
//# sourceMappingURL=use-controllable-machine.d.ts.map