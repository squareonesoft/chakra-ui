import { Dict, StateMachine as S } from "./types";
export declare const isString: (value: any) => value is string;
export declare const isArray: (value: any) => value is any[];
export declare const isObject: (value: any) => value is Record<string, any>;
export declare const isFunction: (value: any) => value is Function;
export declare const keys: <T extends Record<string, any>>(value: T) => string[];
export declare const toArray: <T>(v?: T | T[]) => T[];
export declare function toEvent<T extends string | S.Event>(event: T): S.EventObject | T;
export declare function toTarget<T extends string | {
    target?: string;
}>(target: T): T | {
    target: T & string;
};
export declare function toTransition<TContext extends Dict, TState extends string, TEvent extends S.EventObject>(transition: S.Transitions<TContext, TState, TEvent> | undefined, currentState?: string | null): S.TransitionDefinition<TContext, string, TEvent> | S.TransitionDefinition<TContext, string, TEvent>[] | undefined;
export declare const INTERNAL_EVENTS: {
    INIT: string;
    AFTER: string;
    EVERY: string;
    SEND_PARENT: string;
    STOP: string;
    SYNC: string;
};
export declare const MACHINE_TYPES: {
    MACHINE: string;
    ACTOR: string;
};
export declare const toComputed: (obj?: Dict) => {
    [k: string]: (state: any) => any;
};
export declare function isGuardHelper(value: unknown): value is {
    exec: Function;
};
//# sourceMappingURL=utils.d.ts.map