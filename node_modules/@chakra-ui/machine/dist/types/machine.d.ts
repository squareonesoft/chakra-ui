import { Dict, StateMachine as S } from "./types";
export declare enum MachineStatus {
    NotStarted = "Not Started",
    Running = "Running",
    Stopped = "Stopped"
}
/**
 * Machine is used to create, interpret, and execute finite state machines.
 * It is inspired by XState, State Designer and Robot3.
 */
export declare class Machine<TContext extends Dict, TState extends string, TEvent extends S.EventObject = S.AnyEventObject> {
    status: MachineStatus;
    state: S.State<TContext>;
    config: S.MachineConfig<TContext, TState, TEvent>;
    options: S.MachineOptions<TContext, TEvent> | undefined;
    context: TContext;
    id: string;
    __type: string;
    private disposables;
    private afterEventsMap;
    private parent?;
    private children;
    private guardsMap?;
    private actionsMap?;
    private delaysMap?;
    constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TEvent>);
    start: () => this | undefined;
    stop: () => this | undefined;
    private stopAfterEvents;
    private stopActivities;
    private stopChildren;
    private setParent;
    spawn: (src: MachineSrc<any, any>, id?: string) => Machine<any, any, S.AnyEventObject>;
    private addCleanup;
    private assignState;
    private assignTags;
    subscribe: (listener: S.SubscribeFunction<TContext>) => () => void;
    /**
     * Used to create a new machine from existing machine
     * but with modified context.
     */
    withContext: (context: Partial<TContext>) => Machine<TContext, TState, TEvent>;
    withConfig: (config: Partial<S.MachineConfig<TContext, TState, TEvent>>) => Machine<TContext, TState, TEvent>;
    withOptions: (options: Partial<S.MachineOptions<TContext, TEvent>>) => Machine<TContext, TState, TEvent>;
    private isFinalState;
    private getStateConfig;
    private getNextState;
    /**
     * Check if a state has running activities. A state is considering to
     * have running activity if it defined `activities` or `every`
     */
    private hasActivities;
    /**
     * Delay can be specified as:
     * - a string (reference to `options.delays`)
     * - a number (in ms)
     * - a function that returns a number (in ms)
     *
     * Let's resolve this to a number
     */
    private determineDelay;
    /**
     * Guards or conditions can be specified as:
     * - a string (reference to `options.guards`)
     * - a function that returns a number (in ms)
     */
    private determineGuard;
    /**
     * A transition is an object that describes the next state, or/and actions
     * that should run when an event is sent.
     *
     * Transitions can be specified as:
     * - A single string: "spinning"
     * - An object with `target`, `actions`, or `cond`: { target: "spinning", actions: [...], cond: isValid }
     * - An array of possible transitions. In this case, we'll pick the first matching transition
     * depending on the `cond` specified
     */
    private pickTransition;
    /**
     * All `after` events leverage `setTimeout` and `clearTimeout`,
     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.
     *
     * To achieve this, we split the after into `entry` and `exit` functions and
     * append them to the normal `entry` and `exit` actions
     */
    private convertAfterToActions;
    /**
     * Function to executes defined actions. It can accept actions as string
     * (referencing `options.actionsMap`) or actual functions.
     */
    private executeActions;
    /**
     * Function to execute running activities and registers
     * their cleanup function internally (to be called later on when we exit the state)
     */
    private executeActivities;
    /**
     * Normalizes the `every` definition to object transition. Every transitions
     * can be:
     * - An array of possible actions to run (we need to pick the first match based on cond)
     * - An object of intervals and actions
     */
    private createEveryActivities;
    private setEvent;
    /**
     * Performs all the requires side-effects or reactions when
     * we move from state A => state B.
     *
     * The Effect order:
     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)
     */
    private performTransitionSideEffects;
    /**
     * Check if the next state is transient and updates the
     * next state to go to target of transient state.
     */
    private checkTransient;
    /**
     * Function to send event to parent machine from spawned child
     */
    sendParent: (evt: Event) => void;
    /**
     * Function to send event to spawned child machine or actor
     */
    sendChild: (evt: Event, to: string | ((ctx: TContext) => string)) => void;
    /**
     * Function to stop a running child machine or actor
     */
    stopChild: (child: Machine<any, any>) => void;
    /**
     * Function to send an event to current machine
     */
    send: (evt: string | TEvent) => void;
    transition: (stateNode: S.StateNode<TContext, TState, TEvent> | undefined, evt: TEvent | string) => S.StateNode<TContext, TState, TEvent> | undefined;
}
export declare type MachineSrc<C extends Dict, S extends string, E extends S.EventObject = S.AnyEventObject> = Machine<C, S, E> | (() => Machine<C, S, E>);
//# sourceMappingURL=machine.d.ts.map