function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable react/static-property-placement */
import { nanoid } from "nanoid";
import { ref, subscribe } from "valtio";
import { proxyWithComputed as proxy } from "valtio/utils";
import { INTERNAL_EVENTS, isArray, isFunction, isObject, isString, keys, MACHINE_TYPES, toArray, toEvent, toTarget, toTransition, toComputed, isGuardHelper } from "./utils";
export var MachineStatus;
/**
 * Machine is used to create, interpret, and execute finite state machines.
 * It is inspired by XState, State Designer and Robot3.
 */

(function (MachineStatus) {
  MachineStatus["NotStarted"] = "Not Started";
  MachineStatus["Running"] = "Running";
  MachineStatus["Stopped"] = "Stopped";
})(MachineStatus || (MachineStatus = {}));

export class Machine {
  // Cleanup function map (per state)
  // For Parent <==> Spawned Actor relationship
  // A map of gaurd, action, delay implementations
  // Let's get started!
  constructor(_config, _options) {
    var _this = this,
        _config$id,
        _config$context;

    _defineProperty(this, "status", MachineStatus.NotStarted);

    _defineProperty(this, "state", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "context", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "__type", MACHINE_TYPES.MACHINE);

    _defineProperty(this, "disposables", new Map());

    _defineProperty(this, "afterEventsMap", new Map());

    _defineProperty(this, "parent", void 0);

    _defineProperty(this, "children", new Map());

    _defineProperty(this, "guardsMap", void 0);

    _defineProperty(this, "actionsMap", void 0);

    _defineProperty(this, "delaysMap", void 0);

    _defineProperty(this, "start", () => {
      // Don't start if it's already running
      if (this.status === MachineStatus.Running) return;
      this.status = MachineStatus.Running;
      this.send(INTERNAL_EVENTS.INIT);
      return this;
    });

    _defineProperty(this, "stop", () => {
      // No need to call if already stopped
      if (this.status === MachineStatus.Stopped) return;
      this.state.current = "";
      this.state.event = INTERNAL_EVENTS.STOP;

      if (this.config.context) {
        this.state.context = this.config.context;
      } // cleanups


      this.stopChildren();
      this.stopActivities();
      this.stopAfterEvents();
      this.status = MachineStatus.Stopped;
      return this;
    });

    _defineProperty(this, "stopAfterEvents", () => {
      this.afterEventsMap.forEach(fns => {
        fns.forEach(stop => stop());
      });
      this.afterEventsMap.clear();
    });

    _defineProperty(this, "stopActivities", key => {
      if (key) {
        var _this$disposables$get;

        (_this$disposables$get = this.disposables.get(key)) == null ? void 0 : _this$disposables$get.forEach(cleanup => cleanup());
        this.disposables.delete(key);
      } else {
        this.disposables.forEach(set => {
          set.forEach(cleanup => cleanup());
        });
        this.disposables.clear();
      }
    });

    _defineProperty(this, "stopChildren", () => {
      this.children.forEach(child => child.stop());
      this.children.clear();
    });

    _defineProperty(this, "setParent", parent => {
      this.parent = parent;
    });

    _defineProperty(this, "spawn", function (src, id) {
      if (id === void 0) {
        id = nanoid();
      }

      var actor = isFunction(src) ? src() : src;
      actor.id = id;
      actor.__type = MACHINE_TYPES.ACTOR;
      actor.setParent(_this);

      _this.children.set(id, actor);

      return ref(actor);
    });

    _defineProperty(this, "addCleanup", (key, cleanup) => {
      if (!this.disposables.has(key)) {
        this.disposables.set(key, new Set([cleanup]));
      } else {
        var _this$disposables$get2;

        (_this$disposables$get2 = this.disposables.get(key)) == null ? void 0 : _this$disposables$get2.add(cleanup);
      }
    });

    _defineProperty(this, "assignState", target => {
      this.state.prev = this.state.current;
      this.state.current = target;
    });

    _defineProperty(this, "assignTags", next => {
      var _next$stateNode$tags, _next$stateNode;

      this.state.tags = new Set((_next$stateNode$tags = (_next$stateNode = next.stateNode) == null ? void 0 : _next$stateNode.tags) != null ? _next$stateNode$tags : []);
    });

    _defineProperty(this, "subscribe", listener => {
      return subscribe(this.state, () => {
        this.context = this.state.context;
        listener(this.state);
      });
    });

    _defineProperty(this, "withContext", context => {
      var newContext = _extends({}, this.config.context, context);

      return new Machine(_extends({}, this.config, {
        context: newContext
      }), this.options);
    });

    _defineProperty(this, "withConfig", config => {
      return new Machine(_extends({}, this.config, config), this.options);
    });

    _defineProperty(this, "withOptions", options => {
      return new Machine(this.config, _extends({}, this.options, options));
    });

    _defineProperty(this, "isFinalState", stateNode => {
      return stateNode.type === "final";
    });

    _defineProperty(this, "getStateConfig", state => {
      if (!state) return;
      return this.config.states[state];
    });

    _defineProperty(this, "getNextState", (event, transitions) => {
      var _transition$target;

      var transition = this.pickTransition(event, transitions);
      var stateNode = transition ? this.getStateConfig((_transition$target = transition.target) != null ? _transition$target : this.state.current) : undefined;
      var isTransient = !!(stateNode != null && stateNode.always);
      return {
        transition,
        stateNode,
        hasTarget: !!transition,
        isTransient,
        target: transition == null ? void 0 : transition.target
      };
    });

    _defineProperty(this, "hasActivities", state => {
      if (!state) return false;
      return state.activities || state.every;
    });

    _defineProperty(this, "determineDelay", (delay, event) => {
      if (typeof delay === "number") {
        return delay;
      }

      if (isFunction(delay)) {
        return delay(this.state.context, event);
      }

      if (isString(delay)) {
        if (this.delaysMap) {
          var _this$delaysMap;

          var value = (_this$delaysMap = this.delaysMap) == null ? void 0 : _this$delaysMap[delay];
          return isFunction(value) ? value(this.state.context, event) : value;
        }

        return Number(delay);
      }

      return delay;
    });

    _defineProperty(this, "determineGuard", cond => {
      if (isString(cond)) {
        var _this$guardsMap;

        return (_this$guardsMap = this.guardsMap) == null ? void 0 : _this$guardsMap[cond];
      }

      if (isGuardHelper(cond)) {
        var _this$guardsMap2;

        return cond.exec((_this$guardsMap2 = this.guardsMap) != null ? _this$guardsMap2 : {});
      }

      return cond;
    });

    _defineProperty(this, "pickTransition", (event, transitions) => {
      return toArray(transitions).find(t => {
        var _ref, _cond;

        // convert to transition object, if it's a string
        var transition = toTarget(t); // get condition function

        var cond = this.determineGuard(transition.cond);
        return (_ref = (_cond = cond == null ? void 0 : cond(this.state.context, event)) != null ? _cond : transition.target) != null ? _ref : transition.actions;
      });
    });

    _defineProperty(this, "convertAfterToActions", state => {
      var _this$getStateConfig;

      var event = toEvent(INTERNAL_EVENTS.AFTER);
      var {
        after
      } = (_this$getStateConfig = this.getStateConfig(state)) != null ? _this$getStateConfig : {};
      if (!after) return;
      var entries = [];
      var exits = [];

      var toActions = transition => {
        var _this$determineDelay;

        // get the computed delay
        var delay = (_this$determineDelay = this.determineDelay(transition.delay, event)) != null ? _this$determineDelay : 0;
        var id;
        return {
          entry: () => {
            id = setTimeout(() => {
              var next = this.getNextState(event, transition);
              var current = this.getStateConfig(this.state.current);

              if (current) {
                this.performTransitionSideEffects(current, next, event);
              }
            }, delay);
          },
          exit: () => {
            clearTimeout(id);
          }
        };
      };

      if (isArray(after)) {
        var transition = this.pickTransition(event, after);
        if (!transition) return;
        var t = isString(transition) ? {
          target: transition
        } : transition;
        var {
          entry,
          exit
        } = toActions(t);
        entries.push(entry);
        exits.push(exit);
      } else if (isObject(after)) {
        for (var delay in after) {
          var _transition2 = after[delay];

          var _transition = void 0;

          if (isArray(_transition2)) {
            var picked = this.pickTransition(event, _transition2);
            if (picked) _transition = picked;
          } else if (isString(_transition2)) {
            _transition = {
              target: _transition2,
              delay
            };
          } else {
            _transition = _extends({}, _transition2, {
              delay
            });
          } //@ts-ignore


          var {
            entry: _entry,
            exit: _exit
          } = toActions(_transition);
          entries.push(_entry);
          exits.push(_exit);
        }
      }

      return {
        entries,
        exits
      };
    });

    _defineProperty(this, "executeActions", (event, actions) => {
      if (!actions) return;
      actions = toArray(actions);

      for (var action of actions) {
        var _this$actionsMap, _this$actionsMap2;

        if (isString(action) && !((_this$actionsMap = this.actionsMap) != null && _this$actionsMap[action])) {
          console.warn(action + " not implemented in " + this.id);
        }

        var fn = isString(action) ? (_this$actionsMap2 = this.actionsMap) == null ? void 0 : _this$actionsMap2[action] : action;
        fn == null ? void 0 : fn(this.state.context, event);
      }
    });

    _defineProperty(this, "executeActivities", (event, activities) => {
      if (isArray(activities)) {
        for (var _activity of activities) {
          var cleanup = _activity(this.state.context, event);

          this.addCleanup(this.state.current, cleanup);
        }
      } else {
        var _cleanup = activities == null ? void 0 : activities(this.state.context, event);

        this.addCleanup(this.state.current, _cleanup);
      }
    });

    _defineProperty(this, "createEveryActivities", (every, iterator) => {
      if (!every) return;
      var event = toEvent(INTERNAL_EVENTS.EVERY); // every: [{ interval: 2000, actions: [...], cond: "isValid" },  { interval: 1000, actions: [...] }]

      if (isArray(every)) {
        var _this$determineDelay2;

        // picked = { interval: string | number | <ref>, actions: [...], cond: ... }
        var picked = toArray(every).find(t => {
          var _cond2;

          t.interval = this.determineDelay(t.interval, event);
          var cond = t.cond ? this.determineGuard(t.cond) : undefined;
          return (_cond2 = cond == null ? void 0 : cond(this.state.context, event)) != null ? _cond2 : t.interval;
        });
        if (!picked) return;
        var ms = (_this$determineDelay2 = this.determineDelay(picked.interval, event)) != null ? _this$determineDelay2 : 0;

        var _activity2 = (_, event) => {
          var id = setInterval(() => {
            this.executeActions(event, picked.actions);
          }, ms);
          return () => clearInterval(id);
        };

        iterator(_activity2);
      } else {
        var _loop = function _loop(interval) {
          var _this$determineDelay3;

          var actions = every == null ? void 0 : every[interval]; // interval could be a `ref` not the actual interval value, let's determine the actual value

          var ms = (_this$determineDelay3 = _this.determineDelay(interval, event)) != null ? _this$determineDelay3 : 0; // create the activity to run for each `every` reaction

          var activity = (_, event) => {
            var id = setInterval(() => {
              _this.executeActions(event, actions);
            }, ms);
            return () => clearInterval(id);
          };

          iterator(activity);
        };

        // every = { 1000: [fn, fn] | fn, [ref]: fn }
        for (var interval in every) {
          _loop(interval);
        }
      }
    });

    _defineProperty(this, "setEvent", event => {
      var eventType = toEvent(event).type;
      this.state.event = eventType === INTERNAL_EVENTS.SYNC ? [this.state.event, INTERNAL_EVENTS.SYNC].join(" > ") : eventType;
    });

    _defineProperty(this, "performTransitionSideEffects", (current, next, event) => {
      var _next$target, _next$transition;

      this.setEvent(event);
      next.target = (_next$target = next.target) != null ? _next$target : this.state.current;
      var changed = next.target !== this.state.current;

      var go = next => changed && next.target;

      if (go(next)) {
        // get explicit exit and implicit "after.exit" actions for current state
        var exitActions = toArray(current == null ? void 0 : current.exit);
        var afterExitActions = this.afterEventsMap.get(this.state.current);

        if (afterExitActions) {
          exitActions.push(...afterExitActions);
        } // call all exit actions for current state


        this.executeActions(event, exitActions); // cleanup activities for current state

        if (current && this.hasActivities(current)) {
          this.stopActivities(this.state.current);
        }
      } // execute transition actions


      this.executeActions(event, next == null ? void 0 : (_next$transition = next.transition) == null ? void 0 : _next$transition.actions); // go to next state

      this.assignState(next.target);
      this.assignTags(next);

      if (go(next)) {
        var _next$stateNode2, _next$stateNode3, _next$stateNode4, _next$stateNode5;

        // get all entry actions
        var entryActions = toArray((_next$stateNode2 = next.stateNode) == null ? void 0 : _next$stateNode2.entry);
        var afterActions = this.convertAfterToActions(next.target);

        if ((_next$stateNode3 = next.stateNode) != null && _next$stateNode3.after && afterActions) {
          this.afterEventsMap.set(next.target, afterActions == null ? void 0 : afterActions.exits);
          entryActions.push(...afterActions.entries);
        } // execute entry actions for next state


        this.executeActions(event, entryActions); // execute activities for next state

        var activities = toArray((_next$stateNode4 = next.stateNode) == null ? void 0 : _next$stateNode4.activities); // if `every` is defined, create an activity and append to activities

        this.createEveryActivities((_next$stateNode5 = next.stateNode) == null ? void 0 : _next$stateNode5.every, activity => {
          activities.unshift(activity);
        });

        if (activities.length > 0) {
          this.executeActivities(event, activities);
        }

        if (next.stateNode && this.isFinalState(next.stateNode)) {
          this.state.done = true;
        }
      }
    });

    _defineProperty(this, "checkTransient", (next, event) => {
      var _next$stateNode6;

      if (!((_next$stateNode6 = next.stateNode) != null && _next$stateNode6.always)) return next;
      var dfn = next.stateNode.always;
      var transition = toTransition(dfn, null);

      var _transition = isArray(transition) ? this.pickTransition(event, transition) : transition;

      if (_transition != null && _transition.target) {
        next = this.getNextState(event, _transition);
      }

      if (!(_transition != null && _transition.target) && _transition != null && _transition.actions) {
        // execute transient actions
        var cond = this.determineGuard(_transition.cond) || (() => true);

        if (cond(this.state.context, event)) {
          this.executeActions(event, _transition.actions);
        }
      }

      return next;
    });

    _defineProperty(this, "sendParent", evt => {
      var _this$parent;

      var event = toEvent(evt);
      event.src = INTERNAL_EVENTS.SEND_PARENT;
      (_this$parent = this.parent) == null ? void 0 : _this$parent.send(event);
    });

    _defineProperty(this, "sendChild", (evt, to) => {
      var event = toEvent(evt);
      var id = typeof to === "function" ? to(this.state.context) : to;
      var child = this.children.get(id);
      child == null ? void 0 : child.send(event);
    });

    _defineProperty(this, "stopChild", child => {
      if (this.children.has(child.id)) {
        child.stop();
        this.children.delete(child.id);
      }
    });

    _defineProperty(this, "send", evt => {
      var event = toEvent(evt);
      var isInit = event.type === INTERNAL_EVENTS.INIT;
      var stateNode = this.getStateConfig(this.state.current);

      if (isInit) {
        var next = this.getNextState(event, {
          target: this.config.initial
        }); //@ts-ignore

        next = this.checkTransient(next, event);
        this.performTransitionSideEffects(stateNode, next, event);
      } else {
        this.transition(stateNode, event);
      }
    });

    _defineProperty(this, "transition", (stateNode, evt) => {
      var _stateNode$on$event$t, _stateNode$on, _this$config$on;

      var event = toEvent(evt);

      if (!stateNode && !this.config.on) {
        throw new Error("[machine]: state node has no definition");
      }

      var _transition = (_stateNode$on$event$t = stateNode == null ? void 0 : (_stateNode$on = stateNode.on) == null ? void 0 : _stateNode$on[event.type]) != null ? _stateNode$on$event$t : (_this$config$on = this.config.on) == null ? void 0 : _this$config$on[event.type];

      var transition = toTransition(_transition, this.state.current);
      if (!transition) return;
      var next = this.getNextState(event, transition); //@ts-ignore

      next = this.checkTransient(next, event);
      this.performTransitionSideEffects(stateNode, next, event);
      return next.stateNode;
    });

    this.options = _options;
    this.config = _config;
    this.id = (_config$id = _config.id) != null ? _config$id : "machine-" + nanoid();

    var _context = (_config$context = _config.context) != null ? _config$context : {};

    this.context = _context;
    this.state = proxy({
      current: "",
      prev: "",
      event: "",
      context: _context,
      done: false,
      tags: new Set(),

      hasTag(tag) {
        return this.tags.has(tag);
      },

      matches(value) {
        return isArray(value) ? value.includes(this.current) : this.current === value;
      }

    }, _extends({}, toComputed(_options == null ? void 0 : _options.computed), {
      nextEvents(self) {
        var _self$current$on, _config$states, _config$states$self$c, _config$on;

        var stateEvents = (_self$current$on = (_config$states = _config.states) == null ? void 0 : (_config$states$self$c = _config$states[self.current]) == null ? void 0 : _config$states$self$c["on"]) != null ? _self$current$on : {};
        var globalEvents = (_config$on = _config == null ? void 0 : _config.on) != null ? _config$on : {};
        Object.assign(stateEvents, globalEvents);
        return keys(stateEvents).filter(event => event !== INTERNAL_EVENTS.SYNC);
      },

      changed(self) {
        if (self.event === INTERNAL_EVENTS.INIT || !self.prev) return false;
        return self.current !== self.prev;
      }

    }));
    if (_options != null && _options.guards) this.guardsMap = _options.guards;
    if (_options != null && _options.actions) this.actionsMap = _options.actions;
    if (_options != null && _options.delays) this.delaysMap = _options.delays;
  } // Starts the interpreted machine.


}
//# sourceMappingURL=machine.js.map