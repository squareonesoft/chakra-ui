{"version":3,"sources":["../../src/guards.ts"],"names":["or","conditions","exec","guards","ctx","event","some","condition","and","every","not"],"mappings":"AAEA,SAASA,EAAT,GAEkD;AAAA,oCAD7CC,UAC6C;AAD7CA,IAAAA,UAC6C;AAAA;;AAChD,SAAO;AACLC,IAAAA,IAAI,EAAGC,MAAD,IAAkB,CAACC,GAAD,EAAgBC,KAAhB,KACtBJ,UAAU,CAACK,IAAX,CAAiBC,SAAD,IAAe;AAC7B,UAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AAAA;;AACjC,oCAAOJ,MAAM,CAACI,SAAD,CAAb,qBAAO,uBAAAJ,MAAM,EAAcC,GAAd,EAAmBC,KAAnB,CAAb;AACD;;AACD,aAAOE,SAAS,CAACL,IAAV,CAAeC,MAAf,EAAuBC,GAAvB,EAA4BC,KAA5B,CAAP;AACD,KALD;AAFG,GAAP;AASD;;AAED,SAASG,GAAT,GAEkD;AAAA,qCAD7CP,UAC6C;AAD7CA,IAAAA,UAC6C;AAAA;;AAChD,SAAO;AACLC,IAAAA,IAAI,EAAGC,MAAD,IAAkB,CAACC,GAAD,EAAgBC,KAAhB,KACtBJ,UAAU,CAACQ,KAAX,CAAkBF,SAAD,IAAe;AAC9B,UAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AAAA;;AACjC,qCAAOJ,MAAM,CAACI,SAAD,CAAb,qBAAO,wBAAAJ,MAAM,EAAcC,GAAd,EAAmBC,KAAnB,CAAb;AACD;;AACD,aAAOE,SAAS,CAACL,IAAV,CAAeC,MAAf,EAAuBC,GAAvB,EAA4BC,KAA5B,CAAP;AACD,KALD;AAFG,GAAP;AASD;;AAED,SAASK,GAAT,CACEH,SADF,EAEkD;AAChD,SAAO;AACLL,IAAAA,IAAI,EAAGC,MAAD,IAAkB,CAACC,GAAD,EAAgBC,KAAhB,KAAkC;AACxD,UAAI,OAAOE,SAAP,KAAqB,QAAzB,EAAmC;AAAA;;AACjC,eAAO,wBAACJ,MAAM,CAACI,SAAD,CAAP,aAAC,wBAAAJ,MAAM,EAAcC,GAAd,EAAmBC,KAAnB,CAAP,CAAP;AACD;;AACD,aAAO,CAACE,SAAS,CAACL,IAAV,CAAeC,MAAf,EAAuBC,GAAvB,EAA4BC,KAA5B,CAAR;AACD;AANI,GAAP;AAQD;;AAED,OAAO,IAAMF,MAAM,GAAG;AAAEH,EAAAA,EAAF;AAAMQ,EAAAA,GAAN;AAAWE,EAAAA;AAAX,CAAf","sourcesContent":["import { Dict, StateMachine } from \"./types\"\n\nfunction or<TContext extends Dict, TEvent extends StateMachine.EventObject>(\n  ...conditions: Array<string | StateMachine.ConditionHelper<TContext, TEvent>>\n): StateMachine.ConditionHelper<TContext, TEvent> {\n  return {\n    exec: (guards: Dict) => (ctx: TContext, event: TEvent) =>\n      conditions.some((condition) => {\n        if (typeof condition === \"string\") {\n          return guards[condition]?.(ctx, event)\n        }\n        return condition.exec(guards)(ctx, event)\n      }),\n  }\n}\n\nfunction and<TContext extends Dict, TEvent extends StateMachine.EventObject>(\n  ...conditions: Array<string | StateMachine.ConditionHelper<TContext, TEvent>>\n): StateMachine.ConditionHelper<TContext, TEvent> {\n  return {\n    exec: (guards: Dict) => (ctx: TContext, event: TEvent) =>\n      conditions.every((condition) => {\n        if (typeof condition === \"string\") {\n          return guards[condition]?.(ctx, event)\n        }\n        return condition.exec(guards)(ctx, event)\n      }),\n  }\n}\n\nfunction not<TContext extends Dict, TEvent extends StateMachine.EventObject>(\n  condition: string | StateMachine.ConditionHelper<TContext, TEvent>,\n): StateMachine.ConditionHelper<TContext, TEvent> {\n  return {\n    exec: (guards: Dict) => (ctx: TContext, event: TEvent) => {\n      if (typeof condition === \"string\") {\n        return !guards[condition]?.(ctx, event)\n      }\n      return !condition.exec(guards)(ctx, event)\n    },\n  }\n}\n\nexport const guards = { or, and, not }\n"],"file":"guards.js"}