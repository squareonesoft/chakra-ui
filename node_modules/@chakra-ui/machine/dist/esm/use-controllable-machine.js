function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from "react";
import { createMachine } from "./create-machine";
import { useMachine } from "./use-machine";
import { INTERNAL_EVENTS } from "./utils";

var useUpdateEffect = (effect, deps) => {
  var mounted = React.useRef(false);
  React.useEffect(() => {
    if (mounted.current) {
      return effect();
    }

    mounted.current = true;
    return undefined; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
};

export var createControllableMachine = (config, opts) => createMachine(_extends({}, config, {
  on: _extends({}, config.on, {
    [INTERNAL_EVENTS.SYNC]: {
      actions: (ctx, event) => {
        ctx.value = event.value;
      }
    }
  })
}), opts);
/**
 * Takes a machine that has `value` in its context and makes it controllable
 * by handling `value`, `defaultValue` and `onChange`
 */

export var useControllableMachine = (machine, props) => {
  var {
    value: valueProp,
    defaultValue,
    onChange
  } = props,
      rest = _objectWithoutPropertiesLoose(props, ["value", "defaultValue", "onChange"]);

  var isControlled = valueProp !== undefined;
  var [valueState] = React.useState(defaultValue);
  var value = isControlled ? valueProp : valueState; //@ts-expect-error

  var [state, send] = useMachine(() => {
    var context = _extends({}, rest, {
      value,

      setValue(nextValue) {
        onChange == null ? void 0 : onChange(nextValue);

        if (!isControlled) {
          this.value = nextValue;
        }
      }

    });

    return machine.withContext(context);
  });
  useUpdateEffect(() => {
    send({
      type: INTERNAL_EVENTS.SYNC,
      value: valueProp
    });
  }, [valueProp, send]);
  return [state, send];
};
//# sourceMappingURL=use-controllable-machine.js.map