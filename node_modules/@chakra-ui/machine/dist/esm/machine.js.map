{"version":3,"sources":["../../src/machine.ts"],"names":["nanoid","ref","subscribe","proxyWithComputed","proxy","INTERNAL_EVENTS","isArray","isFunction","isObject","isString","keys","MACHINE_TYPES","toArray","toEvent","toTarget","toTransition","toComputed","isGuardHelper","MachineStatus","Machine","constructor","config","options","NotStarted","MACHINE","Map","status","Running","send","INIT","Stopped","state","current","event","STOP","context","stopChildren","stopActivities","stopAfterEvents","afterEventsMap","forEach","fns","stop","clear","key","disposables","get","cleanup","delete","set","children","child","parent","src","id","actor","__type","ACTOR","setParent","has","Set","add","target","prev","next","tags","stateNode","listener","newContext","type","states","transitions","transition","pickTransition","getStateConfig","undefined","isTransient","always","hasTarget","activities","every","delay","delaysMap","value","Number","cond","guardsMap","exec","find","t","determineGuard","actions","AFTER","after","entries","exits","toActions","determineDelay","entry","setTimeout","getNextState","performTransitionSideEffects","exit","clearTimeout","push","_transition","picked","action","actionsMap","console","warn","fn","activity","addCleanup","iterator","EVERY","interval","ms","_","setInterval","executeActions","clearInterval","eventType","SYNC","join","setEvent","changed","go","exitActions","afterExitActions","hasActivities","assignState","assignTags","entryActions","afterActions","convertAfterToActions","createEveryActivities","unshift","length","executeActivities","isFinalState","done","dfn","evt","SEND_PARENT","to","isInit","initial","checkTransient","on","Error","hasTag","tag","matches","includes","computed","nextEvents","self","stateEvents","globalEvents","Object","assign","filter","guards","delays"],"mappings":"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","sourcesContent":["/* eslint-disable react/static-property-placement */\nimport { nanoid } from \"nanoid\"\nimport { ref, subscribe } from \"valtio\"\nimport { proxyWithComputed as proxy } from \"valtio/utils\"\nimport { Dict, MaybeArray, StateMachine as S } from \"./types\"\nimport {\n  INTERNAL_EVENTS,\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  keys,\n  MACHINE_TYPES,\n  toArray,\n  toEvent,\n  toTarget,\n  toTransition,\n  toComputed,\n  isGuardHelper,\n} from \"./utils\"\n\nexport enum MachineStatus {\n  NotStarted = \"Not Started\",\n  Running = \"Running\",\n  Stopped = \"Stopped\",\n}\n\n/**\n * Machine is used to create, interpret, and execute finite state machines.\n * It is inspired by XState, State Designer and Robot3.\n */\nexport class Machine<\n  TContext extends Dict,\n  TState extends string,\n  TEvent extends S.EventObject = S.AnyEventObject\n> {\n  status: MachineStatus = MachineStatus.NotStarted\n  state: S.State<TContext>\n  config: S.MachineConfig<TContext, TState, TEvent>\n  options: S.MachineOptions<TContext, TEvent> | undefined\n  context: TContext\n  id: string\n  __type = MACHINE_TYPES.MACHINE\n\n  // Cleanup function map (per state)\n  private disposables = new Map<string, Set<VoidFunction>>()\n  private afterEventsMap = new Map<string, any[]>()\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: Machine<any, any>\n  private children = new Map<string, Machine<any, any>>()\n\n  // A map of gaurd, action, delay implementations\n  private guardsMap?: S.GuardsMap<TContext, TEvent>\n  private actionsMap?: S.ActionsMap<TContext, TEvent>\n  private delaysMap?: S.TimersMap<TContext, TEvent>\n\n  // Let's get started!\n  constructor(\n    config: S.MachineConfig<TContext, TState, TEvent>,\n    options?: S.MachineOptions<TContext, TEvent>,\n  ) {\n    this.options = options\n    this.config = config\n    this.id = config.id ?? `machine-${nanoid()}`\n    const context = config.context ?? ({} as TContext)\n    this.context = context\n    this.state = proxy(\n      {\n        current: \"\",\n        prev: \"\",\n        event: \"\",\n        context,\n        done: false,\n        tags: new Set<string>(),\n        hasTag(tag: string): boolean {\n          return this.tags.has(tag)\n        },\n        matches(value: string | string[]): boolean {\n          return isArray(value)\n            ? value.includes(this.current)\n            : this.current === value\n        },\n      },\n      {\n        ...toComputed(options?.computed),\n        nextEvents(self) {\n          const stateEvents =\n            (config.states as Dict)?.[self.current]?.[\"on\"] ?? {}\n          const globalEvents = config?.on ?? {}\n          Object.assign(stateEvents, globalEvents)\n          return keys(stateEvents).filter(\n            (event) => event !== INTERNAL_EVENTS.SYNC,\n          )\n        },\n        changed(self) {\n          if (self.event === INTERNAL_EVENTS.INIT || !self.prev) return false\n          return self.current !== self.prev\n        },\n      },\n    )\n\n    if (options?.guards) this.guardsMap = options.guards\n    if (options?.actions) this.actionsMap = options.actions\n    if (options?.delays) this.delaysMap = options.delays\n  }\n\n  // Starts the interpreted machine.\n  start = () => {\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) return\n\n    this.status = MachineStatus.Running\n    this.send(INTERNAL_EVENTS.INIT)\n    return this\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    this.state.current = \"\"\n    this.state.event = INTERNAL_EVENTS.STOP\n    if (this.config.context) {\n      this.state.context = this.config.context\n    }\n    // cleanups\n    this.stopChildren()\n    this.stopActivities()\n    this.stopAfterEvents()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopAfterEvents = () => {\n    this.afterEventsMap.forEach((fns) => {\n      fns.forEach((stop) => stop())\n    })\n    this.afterEventsMap.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (key?: string) => {\n    if (key) {\n      this.disposables.get(key)?.forEach((cleanup) => cleanup())\n      this.disposables.delete(key)\n    } else {\n      this.disposables.forEach((set) => {\n        set.forEach((cleanup) => cleanup())\n      })\n      this.disposables.clear()\n    }\n  }\n\n  // Stop and delete spawned children\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  spawn = (src: MachineSrc<any, any>, id = nanoid()) => {\n    const actor = isFunction(src) ? src() : src\n    actor.id = id\n    actor.__type = MACHINE_TYPES.ACTOR\n    actor.setParent(this)\n    this.children.set(id, actor)\n    return ref(actor)\n  }\n\n  private addCleanup = (key: string, cleanup: VoidFunction) => {\n    if (!this.disposables.has(key)) {\n      this.disposables.set(key, new Set([cleanup]))\n    } else {\n      this.disposables.get(key)?.add(cleanup)\n    }\n  }\n\n  private assignState = (target: string) => {\n    this.state.prev = this.state.current\n    this.state.current = target\n  }\n\n  private assignTags = (next: S.StateInfo<TContext, TState, TEvent>) => {\n    this.state.tags = new Set(next.stateNode?.tags ?? [])\n  }\n\n  subscribe = (listener: S.SubscribeFunction<TContext>) => {\n    return subscribe(this.state, () => {\n      this.context = this.state.context\n      listener(this.state)\n    })\n  }\n\n  /**\n   * Used to create a new machine from existing machine\n   * but with modified context.\n   */\n  withContext = (context: Partial<TContext>) => {\n    const newContext = { ...this.config.context, ...context } as TContext\n    return new Machine({ ...this.config, context: newContext }, this.options)\n  }\n\n  withConfig = (config: Partial<S.MachineConfig<TContext, TState, TEvent>>) => {\n    return new Machine({ ...this.config, ...config }, this.options)\n  }\n\n  withOptions = (options: Partial<S.MachineOptions<TContext, TEvent>>) => {\n    return new Machine(this.config, { ...this.options, ...options })\n  }\n\n  private isFinalState = (stateNode: S.StateNode<TContext, TState, TEvent>) => {\n    return stateNode.type === \"final\"\n  }\n\n  private getStateConfig = (state: string) => {\n    if (!state) return\n    type StateConfig = S.StateNode<TContext, TState, TEvent>\n    return (this.config.states as Dict)[state] as StateConfig\n  }\n\n  private getNextState = (\n    event: TEvent,\n    transitions: S.Transitions<TContext, TState, TEvent>,\n  ) => {\n    const transition = this.pickTransition(event, transitions)\n\n    const stateNode = transition\n      ? this.getStateConfig(transition.target ?? this.state.current)\n      : undefined\n\n    const isTransient = !!stateNode?.always\n\n    return {\n      transition,\n      stateNode,\n      hasTarget: !!transition,\n      isTransient,\n      target: transition?.target,\n    }\n  }\n\n  /**\n   * Check if a state has running activities. A state is considering to\n   * have running activity if it defined `activities` or `every`\n   */\n  private hasActivities = (state: S.StateNode<TContext, TState, TEvent>) => {\n    if (!state) return false\n    return state.activities || state.every\n  }\n\n  /**\n   * Delay can be specified as:\n   * - a string (reference to `options.delays`)\n   * - a number (in ms)\n   * - a function that returns a number (in ms)\n   *\n   * Let's resolve this to a number\n   */\n  private determineDelay = (\n    delay: S.Delay<TContext, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    if (typeof delay === \"number\") {\n      return delay\n    }\n\n    if (isFunction(delay)) {\n      return delay(this.state.context, event)\n    }\n\n    if (isString(delay)) {\n      if (this.delaysMap) {\n        const value = this.delaysMap?.[delay]\n        return isFunction(value) ? value(this.state.context, event) : value\n      }\n      return Number(delay)\n    }\n\n    return delay\n  }\n\n  /**\n   * Guards or conditions can be specified as:\n   * - a string (reference to `options.guards`)\n   * - a function that returns a number (in ms)\n   */\n  private determineGuard = (\n    cond: S.Condition<TContext, TEvent> | undefined,\n  ) => {\n    if (isString(cond)) {\n      return this.guardsMap?.[cond]\n    }\n    if (isGuardHelper(cond)) {\n      return cond.exec(this.guardsMap ?? {})\n    }\n    return cond\n  }\n\n  /**\n   * A transition is an object that describes the next state, or/and actions\n   * that should run when an event is sent.\n   *\n   * Transitions can be specified as:\n   * - A single string: \"spinning\"\n   * - An object with `target`, `actions`, or `cond`: { target: \"spinning\", actions: [...], cond: isValid }\n   * - An array of possible transitions. In this case, we'll pick the first matching transition\n   * depending on the `cond` specified\n   */\n  private pickTransition = (\n    event: TEvent,\n    transitions?: S.Transitions<TContext, TState, TEvent>,\n  ): S.TransitionDefinitionWithDelay<TContext, TState, TEvent> | undefined => {\n    type TransitionDfn = S.TransitionDefinition<TContext, TState, TEvent>\n\n    return toArray(transitions).find((t) => {\n      // convert to transition object, if it's a string\n      const transition = toTarget(t) as TransitionDfn\n      // get condition function\n      const cond = this.determineGuard(transition.cond)\n      return (\n        cond?.(this.state.context, event) ??\n        transition.target ??\n        transition.actions\n      )\n    })\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the after into `entry` and `exit` functions and\n   * append them to the normal `entry` and `exit` actions\n   */\n  private convertAfterToActions = (state: string) => {\n    type DelayedTransition = S.TransitionDefinitionWithDelay<\n      TContext,\n      TState,\n      TEvent\n    >\n\n    const event = toEvent(INTERNAL_EVENTS.AFTER) as TEvent\n    const { after } = this.getStateConfig(state) ?? {}\n\n    if (!after) return\n\n    const entries: any[] = []\n    const exits: any[] = []\n\n    const toActions = (transition: DelayedTransition) => {\n      // get the computed delay\n      const delay = this.determineDelay(transition.delay, event) ?? 0\n\n      let id: any\n\n      return {\n        entry: () => {\n          id = setTimeout(() => {\n            const next = this.getNextState(event, transition)\n            const current = this.getStateConfig(this.state.current)\n            if (current) {\n              this.performTransitionSideEffects(current, next, event)\n            }\n          }, delay)\n        },\n        exit: () => {\n          clearTimeout(id)\n        },\n      }\n    }\n\n    if (isArray(after)) {\n      const transition = this.pickTransition(event, after)\n      if (!transition) return\n\n      const t = isString(transition)\n        ? ({ target: transition } as DelayedTransition)\n        : transition\n\n      const { entry, exit } = toActions(t)\n\n      entries.push(entry)\n      exits.push(exit)\n    } else if (isObject(after)) {\n      for (const delay in after) {\n        const transition = after[delay]\n        let _transition: DelayedTransition\n\n        if (isArray(transition)) {\n          const picked = this.pickTransition(event, transition)\n          if (picked) _transition = picked\n        } else if (isString(transition)) {\n          _transition = { target: transition, delay }\n        } else {\n          _transition = { ...transition, delay }\n        }\n\n        //@ts-ignore\n        const { entry, exit } = toActions(_transition)\n        entries.push(entry)\n        exits.push(exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actionsMap`) or actual functions.\n   */\n  private executeActions = (\n    event: TEvent,\n    actions?: S.Actions<TContext, TEvent>,\n  ) => {\n    if (!actions) return\n    actions = toArray(actions)\n    for (const action of actions) {\n      if (isString(action) && !this.actionsMap?.[action]) {\n        console.warn(`${action} not implemented in ${this.id}`)\n      }\n      const fn = isString(action) ? this.actionsMap?.[action] : action\n      fn?.(this.state.context, event)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: S.Activities<TContext, TEvent>,\n  ) => {\n    if (isArray(activities)) {\n      for (const activity of activities) {\n        const cleanup = activity(this.state.context, event)\n        this.addCleanup(this.state.current, cleanup)\n      }\n    } else {\n      const cleanup = activities?.(this.state.context, event)\n      this.addCleanup(this.state.current, cleanup)\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to object transition. Every transitions\n   * can be:\n   * - An array of possible actions to run (we need to pick the first match based on cond)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"],\n    iterator: (activity: S.Activity<TContext, TEvent>) => void,\n  ) => {\n    if (!every) return\n    const event = toEvent(INTERNAL_EVENTS.EVERY) as TEvent\n\n    // every: [{ interval: 2000, actions: [...], cond: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], cond: ... }\n      const picked = toArray(every).find((t) => {\n        t.interval = this.determineDelay(t.interval, event)\n        const cond = t.cond ? this.determineGuard(t.cond) : undefined\n        return cond?.(this.state.context, event) ?? t.interval\n      })\n\n      if (!picked) return\n\n      const ms = this.determineDelay(picked.interval, event) ?? 0\n\n      const activity = (_: TContext, event: TEvent) => {\n        const id = setInterval(() => {\n          this.executeActions(event, picked.actions)\n        }, ms)\n        return () => clearInterval(id)\n      }\n      iterator(activity)\n    } else {\n      // every = { 1000: [fn, fn] | fn, [ref]: fn }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const ms = this.determineDelay(interval, event) ?? 0\n\n        // create the activity to run for each `every` reaction\n        const activity = (_: TContext, event: TEvent) => {\n          const id = setInterval(() => {\n            this.executeActions(event, actions)\n          }, ms)\n          return () => clearInterval(id)\n        }\n        iterator(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent) => {\n    const eventType = toEvent(event).type\n    this.state.event =\n      eventType === INTERNAL_EVENTS.SYNC\n        ? [this.state.event, INTERNAL_EVENTS.SYNC].join(\" > \")\n        : eventType\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performTransitionSideEffects = (\n    current: S.StateNode<TContext, TState, TEvent> | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    this.setEvent(event)\n    next.target = next.target ?? this.state.current\n\n    const changed = next.target !== this.state.current\n    const go = (next: any): next is { target: any } => changed && next.target\n\n    if (go(next)) {\n      // get explicit exit and implicit \"after.exit\" actions for current state\n      const exitActions = toArray(current?.exit)\n      const afterExitActions = this.afterEventsMap.get(this.state.current)\n      if (afterExitActions) {\n        exitActions.push(...afterExitActions)\n      }\n\n      // call all exit actions for current state\n      this.executeActions(event, exitActions)\n\n      // cleanup activities for current state\n      if (current && this.hasActivities(current)) {\n        this.stopActivities(this.state.current)\n      }\n    }\n\n    // execute transition actions\n    this.executeActions(event, next?.transition?.actions)\n\n    // go to next state\n    this.assignState(next.target)\n    this.assignTags(next)\n\n    if (go(next)) {\n      // get all entry actions\n      const entryActions = toArray(next.stateNode?.entry)\n      const afterActions = this.convertAfterToActions(next.target)\n\n      if (next.stateNode?.after && afterActions) {\n        this.afterEventsMap.set(next.target, afterActions?.exits)\n        entryActions.push(...afterActions.entries)\n      }\n\n      // execute entry actions for next state\n      this.executeActions(event, entryActions)\n\n      // execute activities for next state\n      const activities = toArray(next.stateNode?.activities)\n\n      // if `every` is defined, create an activity and append to activities\n      this.createEveryActivities(next.stateNode?.every, (activity) => {\n        activities.unshift(activity)\n      })\n\n      if (activities.length > 0) {\n        this.executeActivities(event, activities)\n      }\n\n      if (next.stateNode && this.isFinalState(next.stateNode)) {\n        this.state.done = true\n      }\n    }\n  }\n\n  /**\n   * Check if the next state is transient and updates the\n   * next state to go to target of transient state.\n   */\n  private checkTransient = (\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    if (!next.stateNode?.always) return next\n\n    type TransitionDfn = S.TransitionDefinition<TContext, TState, TEvent>\n    const dfn = next.stateNode.always\n    const transition = toTransition(dfn, null) as MaybeArray<TransitionDfn>\n\n    const _transition = isArray(transition)\n      ? this.pickTransition(event, transition)\n      : transition\n\n    if (_transition?.target) {\n      next = this.getNextState(event, _transition)\n    }\n\n    if (!_transition?.target && _transition?.actions) {\n      // execute transient actions\n      const cond = this.determineGuard(_transition.cond) || (() => true)\n      if (cond(this.state.context, event)) {\n        this.executeActions(event, _transition.actions)\n      }\n    }\n\n    return next\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  sendParent = (evt: Event) => {\n    const event = toEvent(evt) as S.EventWithSrc\n    event.src = INTERNAL_EVENTS.SEND_PARENT\n    this.parent?.send(event)\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  sendChild = (evt: Event, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = typeof to === \"function\" ? to(this.state.context) : to\n    const child = this.children.get(id)\n    child?.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  stopChild = (child: Machine<any, any>) => {\n    if (this.children.has(child.id)) {\n      child.stop()\n      this.children.delete(child.id)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  send = (evt: string | TEvent) => {\n    const event = toEvent(evt) as TEvent\n    const isInit = event.type === INTERNAL_EVENTS.INIT\n    const stateNode = this.getStateConfig(this.state.current)\n\n    if (isInit) {\n      let next = this.getNextState(event, { target: this.config.initial })\n      //@ts-ignore\n      next = this.checkTransient(next, event)\n      this.performTransitionSideEffects(stateNode, next, event)\n    } else {\n      this.transition(stateNode, event)\n    }\n  }\n\n  transition = (\n    stateNode: S.StateNode<TContext, TState, TEvent> | undefined,\n    evt: TEvent | string,\n  ) => {\n    type TransitionDfn = S.TransitionDefinition<TContext, TState, TEvent>\n\n    const event = toEvent(evt) as TEvent\n\n    if (!stateNode && !this.config.on) {\n      throw new Error(\"[machine]: state node has no definition\")\n    }\n\n    const _transition =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const transition = toTransition(_transition, this.state.current)\n    if (!transition) return\n\n    let next = this.getNextState(event, transition as TransitionDfn)\n    //@ts-ignore\n    next = this.checkTransient(next, event)\n    this.performTransitionSideEffects(stateNode, next, event)\n    return next.stateNode\n  }\n}\n\nexport type MachineSrc<\n  C extends Dict,\n  S extends string,\n  E extends S.EventObject = S.AnyEventObject\n> = Machine<C, S, E> | (() => Machine<C, S, E>)\n"],"file":"machine.js"}