export var isString = value => typeof value === "string";
export var isArray = value => Array.isArray(value);
export var isObject = value => value != null && typeof value === "object" && !isArray(value);
export var isFunction = value => typeof value === "function";
export var keys = value => Object.keys(value);
export var toArray = function toArray(v) {
  if (v === void 0) {
    v = [];
  }

  return isArray(v) ? v : [v];
};
export function toEvent(event) {
  return isString(event) ? {
    type: event
  } : event;
}
export function toTarget(target) {
  return isString(target) ? {
    target
  } : target;
}
export function toTransition(transition, currentState) {
  var _transition = isString(transition) ? toTarget(transition) : transition;

  var check = t => {
    var isTargetless = t.actions && !t.target;
    if (isTargetless && currentState) t.target = currentState;
    return t;
  };

  if (isArray(_transition)) {
    return _transition.map(check);
  }

  if (isObject(_transition)) {
    return check(_transition);
  }
}
export var INTERNAL_EVENTS = {
  INIT: "machine.init",
  AFTER: "machine.after",
  EVERY: "machine.every",
  SEND_PARENT: "machine.send-parent",
  STOP: "machine.stop",
  SYNC: "machine.sync"
};
export var MACHINE_TYPES = {
  MACHINE: "machine",
  ACTOR: "machine.actor"
};
export var toComputed = function toComputed(obj) {
  if (obj === void 0) {
    obj = {};
  }

  return Object.fromEntries(Object.entries(obj).map((_ref) => {
    var [k, v] = _ref;
    return [k, state => v(state.context)];
  }));
};
export function isGuardHelper(value) {
  return isObject(value) && value.exec != null;
}
//# sourceMappingURL=utils.js.map