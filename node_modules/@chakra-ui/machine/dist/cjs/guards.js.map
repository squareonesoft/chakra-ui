{"version":3,"sources":["../../src/guards.ts"],"names":["or","conditions","exec","guards","ctx","event","some","condition","and","every","not"],"mappings":";;;;;AAEA,SAASA,EAAT,GAEkD;AAAA,oCAD7CC,UAC6C;AAD7CA,IAAAA,UAC6C;AAAA;;AAChD,SAAO;AACLC,IAAAA,IAAI,EAAE,cAACC,MAAD;AAAA,aAAkB,UAACC,GAAD,EAAgBC,KAAhB;AAAA,eACtBJ,UAAU,CAACK,IAAX,CAAgB,UAACC,SAAD,EAAe;AAC7B,cAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AAAA;;AACjC,wCAAOJ,MAAM,CAACI,SAAD,CAAb,qBAAO,uBAAAJ,MAAM,EAAcC,GAAd,EAAmBC,KAAnB,CAAb;AACD;;AACD,iBAAOE,SAAS,CAACL,IAAV,CAAeC,MAAf,EAAuBC,GAAvB,EAA4BC,KAA5B,CAAP;AACD,SALD,CADsB;AAAA,OAAlB;AAAA;AADD,GAAP;AASD;;AAED,SAASG,GAAT,GAEkD;AAAA,qCAD7CP,UAC6C;AAD7CA,IAAAA,UAC6C;AAAA;;AAChD,SAAO;AACLC,IAAAA,IAAI,EAAE,cAACC,MAAD;AAAA,aAAkB,UAACC,GAAD,EAAgBC,KAAhB;AAAA,eACtBJ,UAAU,CAACQ,KAAX,CAAiB,UAACF,SAAD,EAAe;AAC9B,cAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AAAA;;AACjC,yCAAOJ,MAAM,CAACI,SAAD,CAAb,qBAAO,wBAAAJ,MAAM,EAAcC,GAAd,EAAmBC,KAAnB,CAAb;AACD;;AACD,iBAAOE,SAAS,CAACL,IAAV,CAAeC,MAAf,EAAuBC,GAAvB,EAA4BC,KAA5B,CAAP;AACD,SALD,CADsB;AAAA,OAAlB;AAAA;AADD,GAAP;AASD;;AAED,SAASK,GAAT,CACEH,SADF,EAEkD;AAChD,SAAO;AACLL,IAAAA,IAAI,EAAE,cAACC,MAAD;AAAA,aAAkB,UAACC,GAAD,EAAgBC,KAAhB,EAAkC;AACxD,YAAI,OAAOE,SAAP,KAAqB,QAAzB,EAAmC;AAAA;;AACjC,iBAAO,wBAACJ,MAAM,CAACI,SAAD,CAAP,aAAC,wBAAAJ,MAAM,EAAcC,GAAd,EAAmBC,KAAnB,CAAP,CAAP;AACD;;AACD,eAAO,CAACE,SAAS,CAACL,IAAV,CAAeC,MAAf,EAAuBC,GAAvB,EAA4BC,KAA5B,CAAR;AACD,OALK;AAAA;AADD,GAAP;AAQD;;AAEM,IAAMF,MAAM,GAAG;AAAEH,EAAAA,EAAE,EAAFA,EAAF;AAAMQ,EAAAA,GAAG,EAAHA,GAAN;AAAWE,EAAAA,GAAG,EAAHA;AAAX,CAAf","sourcesContent":["import { Dict, StateMachine } from \"./types\"\n\nfunction or<TContext extends Dict, TEvent extends StateMachine.EventObject>(\n  ...conditions: Array<string | StateMachine.ConditionHelper<TContext, TEvent>>\n): StateMachine.ConditionHelper<TContext, TEvent> {\n  return {\n    exec: (guards: Dict) => (ctx: TContext, event: TEvent) =>\n      conditions.some((condition) => {\n        if (typeof condition === \"string\") {\n          return guards[condition]?.(ctx, event)\n        }\n        return condition.exec(guards)(ctx, event)\n      }),\n  }\n}\n\nfunction and<TContext extends Dict, TEvent extends StateMachine.EventObject>(\n  ...conditions: Array<string | StateMachine.ConditionHelper<TContext, TEvent>>\n): StateMachine.ConditionHelper<TContext, TEvent> {\n  return {\n    exec: (guards: Dict) => (ctx: TContext, event: TEvent) =>\n      conditions.every((condition) => {\n        if (typeof condition === \"string\") {\n          return guards[condition]?.(ctx, event)\n        }\n        return condition.exec(guards)(ctx, event)\n      }),\n  }\n}\n\nfunction not<TContext extends Dict, TEvent extends StateMachine.EventObject>(\n  condition: string | StateMachine.ConditionHelper<TContext, TEvent>,\n): StateMachine.ConditionHelper<TContext, TEvent> {\n  return {\n    exec: (guards: Dict) => (ctx: TContext, event: TEvent) => {\n      if (typeof condition === \"string\") {\n        return !guards[condition]?.(ctx, event)\n      }\n      return !condition.exec(guards)(ctx, event)\n    },\n  }\n}\n\nexport const guards = { or, and, not }\n"],"file":"guards.js"}