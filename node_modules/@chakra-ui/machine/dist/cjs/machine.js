"use strict";

exports.__esModule = true;
exports.Machine = exports.MachineStatus = void 0;

var _nanoid = require("nanoid");

var _valtio = require("valtio");

var _utils = require("valtio/utils");

var _utils2 = require("./utils");

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MachineStatus;
/**
 * Machine is used to create, interpret, and execute finite state machines.
 * It is inspired by XState, State Designer and Robot3.
 */

exports.MachineStatus = MachineStatus;

(function (MachineStatus) {
  MachineStatus["NotStarted"] = "Not Started";
  MachineStatus["Running"] = "Running";
  MachineStatus["Stopped"] = "Stopped";
})(MachineStatus || (exports.MachineStatus = MachineStatus = {}));

var Machine = // Cleanup function map (per state)
// For Parent <==> Spawned Actor relationship
// A map of gaurd, action, delay implementations
// Let's get started!
function Machine(_config, _options) {
  var _this = this,
      _config$id,
      _config$context;

  _defineProperty(this, "status", MachineStatus.NotStarted);

  _defineProperty(this, "state", void 0);

  _defineProperty(this, "config", void 0);

  _defineProperty(this, "options", void 0);

  _defineProperty(this, "context", void 0);

  _defineProperty(this, "id", void 0);

  _defineProperty(this, "__type", _utils2.MACHINE_TYPES.MACHINE);

  _defineProperty(this, "disposables", new Map());

  _defineProperty(this, "afterEventsMap", new Map());

  _defineProperty(this, "parent", void 0);

  _defineProperty(this, "children", new Map());

  _defineProperty(this, "guardsMap", void 0);

  _defineProperty(this, "actionsMap", void 0);

  _defineProperty(this, "delaysMap", void 0);

  _defineProperty(this, "start", function () {
    // Don't start if it's already running
    if (_this.status === MachineStatus.Running) return;
    _this.status = MachineStatus.Running;

    _this.send(_utils2.INTERNAL_EVENTS.INIT);

    return _this;
  });

  _defineProperty(this, "stop", function () {
    // No need to call if already stopped
    if (_this.status === MachineStatus.Stopped) return;
    _this.state.current = "";
    _this.state.event = _utils2.INTERNAL_EVENTS.STOP;

    if (_this.config.context) {
      _this.state.context = _this.config.context;
    } // cleanups


    _this.stopChildren();

    _this.stopActivities();

    _this.stopAfterEvents();

    _this.status = MachineStatus.Stopped;
    return _this;
  });

  _defineProperty(this, "stopAfterEvents", function () {
    _this.afterEventsMap.forEach(function (fns) {
      fns.forEach(function (stop) {
        return stop();
      });
    });

    _this.afterEventsMap.clear();
  });

  _defineProperty(this, "stopActivities", function (key) {
    if (key) {
      var _this$disposables$get;

      (_this$disposables$get = _this.disposables.get(key)) == null ? void 0 : _this$disposables$get.forEach(function (cleanup) {
        return cleanup();
      });

      _this.disposables["delete"](key);
    } else {
      _this.disposables.forEach(function (set) {
        set.forEach(function (cleanup) {
          return cleanup();
        });
      });

      _this.disposables.clear();
    }
  });

  _defineProperty(this, "stopChildren", function () {
    _this.children.forEach(function (child) {
      return child.stop();
    });

    _this.children.clear();
  });

  _defineProperty(this, "setParent", function (parent) {
    _this.parent = parent;
  });

  _defineProperty(this, "spawn", function (src, id) {
    if (id === void 0) {
      id = (0, _nanoid.nanoid)();
    }

    var actor = (0, _utils2.isFunction)(src) ? src() : src;
    actor.id = id;
    actor.__type = _utils2.MACHINE_TYPES.ACTOR;
    actor.setParent(_this);

    _this.children.set(id, actor);

    return (0, _valtio.ref)(actor);
  });

  _defineProperty(this, "addCleanup", function (key, cleanup) {
    if (!_this.disposables.has(key)) {
      _this.disposables.set(key, new Set([cleanup]));
    } else {
      var _this$disposables$get2;

      (_this$disposables$get2 = _this.disposables.get(key)) == null ? void 0 : _this$disposables$get2.add(cleanup);
    }
  });

  _defineProperty(this, "assignState", function (target) {
    _this.state.prev = _this.state.current;
    _this.state.current = target;
  });

  _defineProperty(this, "assignTags", function (next) {
    var _next$stateNode$tags, _next$stateNode;

    _this.state.tags = new Set((_next$stateNode$tags = (_next$stateNode = next.stateNode) == null ? void 0 : _next$stateNode.tags) != null ? _next$stateNode$tags : []);
  });

  _defineProperty(this, "subscribe", function (listener) {
    return (0, _valtio.subscribe)(_this.state, function () {
      _this.context = _this.state.context;
      listener(_this.state);
    });
  });

  _defineProperty(this, "withContext", function (context) {
    var newContext = _extends({}, _this.config.context, context);

    return new Machine(_extends({}, _this.config, {
      context: newContext
    }), _this.options);
  });

  _defineProperty(this, "withConfig", function (config) {
    return new Machine(_extends({}, _this.config, config), _this.options);
  });

  _defineProperty(this, "withOptions", function (options) {
    return new Machine(_this.config, _extends({}, _this.options, options));
  });

  _defineProperty(this, "isFinalState", function (stateNode) {
    return stateNode.type === "final";
  });

  _defineProperty(this, "getStateConfig", function (state) {
    if (!state) return;
    return _this.config.states[state];
  });

  _defineProperty(this, "getNextState", function (event, transitions) {
    var _transition$target;

    var transition = _this.pickTransition(event, transitions);

    var stateNode = transition ? _this.getStateConfig((_transition$target = transition.target) != null ? _transition$target : _this.state.current) : undefined;
    var isTransient = !!(stateNode != null && stateNode.always);
    return {
      transition: transition,
      stateNode: stateNode,
      hasTarget: !!transition,
      isTransient: isTransient,
      target: transition == null ? void 0 : transition.target
    };
  });

  _defineProperty(this, "hasActivities", function (state) {
    if (!state) return false;
    return state.activities || state.every;
  });

  _defineProperty(this, "determineDelay", function (delay, event) {
    if (typeof delay === "number") {
      return delay;
    }

    if ((0, _utils2.isFunction)(delay)) {
      return delay(_this.state.context, event);
    }

    if ((0, _utils2.isString)(delay)) {
      if (_this.delaysMap) {
        var _this$delaysMap;

        var value = (_this$delaysMap = _this.delaysMap) == null ? void 0 : _this$delaysMap[delay];
        return (0, _utils2.isFunction)(value) ? value(_this.state.context, event) : value;
      }

      return Number(delay);
    }

    return delay;
  });

  _defineProperty(this, "determineGuard", function (cond) {
    if ((0, _utils2.isString)(cond)) {
      var _this$guardsMap;

      return (_this$guardsMap = _this.guardsMap) == null ? void 0 : _this$guardsMap[cond];
    }

    if ((0, _utils2.isGuardHelper)(cond)) {
      var _this$guardsMap2;

      return cond.exec((_this$guardsMap2 = _this.guardsMap) != null ? _this$guardsMap2 : {});
    }

    return cond;
  });

  _defineProperty(this, "pickTransition", function (event, transitions) {
    return (0, _utils2.toArray)(transitions).find(function (t) {
      var _ref, _cond;

      // convert to transition object, if it's a string
      var transition = (0, _utils2.toTarget)(t); // get condition function

      var cond = _this.determineGuard(transition.cond);

      return (_ref = (_cond = cond == null ? void 0 : cond(_this.state.context, event)) != null ? _cond : transition.target) != null ? _ref : transition.actions;
    });
  });

  _defineProperty(this, "convertAfterToActions", function (state) {
    var _this$getStateConfig;

    var event = (0, _utils2.toEvent)(_utils2.INTERNAL_EVENTS.AFTER);

    var _ref2 = (_this$getStateConfig = _this.getStateConfig(state)) != null ? _this$getStateConfig : {},
        after = _ref2.after;

    if (!after) return;
    var entries = [];
    var exits = [];

    var toActions = function toActions(transition) {
      var _this$determineDelay;

      // get the computed delay
      var delay = (_this$determineDelay = _this.determineDelay(transition.delay, event)) != null ? _this$determineDelay : 0;
      var id;
      return {
        entry: function entry() {
          id = setTimeout(function () {
            var next = _this.getNextState(event, transition);

            var current = _this.getStateConfig(_this.state.current);

            if (current) {
              _this.performTransitionSideEffects(current, next, event);
            }
          }, delay);
        },
        exit: function exit() {
          clearTimeout(id);
        }
      };
    };

    if ((0, _utils2.isArray)(after)) {
      var transition = _this.pickTransition(event, after);

      if (!transition) return;
      var t = (0, _utils2.isString)(transition) ? {
        target: transition
      } : transition;

      var _toActions = toActions(t),
          entry = _toActions.entry,
          exit = _toActions.exit;

      entries.push(entry);
      exits.push(exit);
    } else if ((0, _utils2.isObject)(after)) {
      for (var delay in after) {
        var _transition2 = after[delay];

        var _transition = void 0;

        if ((0, _utils2.isArray)(_transition2)) {
          var picked = _this.pickTransition(event, _transition2);

          if (picked) _transition = picked;
        } else if ((0, _utils2.isString)(_transition2)) {
          _transition = {
            target: _transition2,
            delay: delay
          };
        } else {
          _transition = _extends({}, _transition2, {
            delay: delay
          });
        } //@ts-ignore


        var _toActions2 = toActions(_transition),
            _entry = _toActions2.entry,
            _exit = _toActions2.exit;

        entries.push(_entry);
        exits.push(_exit);
      }
    }

    return {
      entries: entries,
      exits: exits
    };
  });

  _defineProperty(this, "executeActions", function (event, actions) {
    if (!actions) return;
    actions = (0, _utils2.toArray)(actions);

    for (var _iterator = _createForOfIteratorHelperLoose(actions), _step; !(_step = _iterator()).done;) {
      var _this$actionsMap, _this$actionsMap2;

      var action = _step.value;

      if ((0, _utils2.isString)(action) && !((_this$actionsMap = _this.actionsMap) != null && _this$actionsMap[action])) {
        console.warn(action + " not implemented in " + _this.id);
      }

      var fn = (0, _utils2.isString)(action) ? (_this$actionsMap2 = _this.actionsMap) == null ? void 0 : _this$actionsMap2[action] : action;
      fn == null ? void 0 : fn(_this.state.context, event);
    }
  });

  _defineProperty(this, "executeActivities", function (event, activities) {
    if ((0, _utils2.isArray)(activities)) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(activities), _step2; !(_step2 = _iterator2()).done;) {
        var _activity = _step2.value;

        var cleanup = _activity(_this.state.context, event);

        _this.addCleanup(_this.state.current, cleanup);
      }
    } else {
      var _cleanup = activities == null ? void 0 : activities(_this.state.context, event);

      _this.addCleanup(_this.state.current, _cleanup);
    }
  });

  _defineProperty(this, "createEveryActivities", function (every, iterator) {
    if (!every) return;
    var event = (0, _utils2.toEvent)(_utils2.INTERNAL_EVENTS.EVERY); // every: [{ interval: 2000, actions: [...], cond: "isValid" },  { interval: 1000, actions: [...] }]

    if ((0, _utils2.isArray)(every)) {
      var _this$determineDelay2;

      // picked = { interval: string | number | <ref>, actions: [...], cond: ... }
      var picked = (0, _utils2.toArray)(every).find(function (t) {
        var _cond2;

        t.interval = _this.determineDelay(t.interval, event);
        var cond = t.cond ? _this.determineGuard(t.cond) : undefined;
        return (_cond2 = cond == null ? void 0 : cond(_this.state.context, event)) != null ? _cond2 : t.interval;
      });
      if (!picked) return;
      var ms = (_this$determineDelay2 = _this.determineDelay(picked.interval, event)) != null ? _this$determineDelay2 : 0;

      var _activity2 = function _activity2(_, event) {
        var id = setInterval(function () {
          _this.executeActions(event, picked.actions);
        }, ms);
        return function () {
          return clearInterval(id);
        };
      };

      iterator(_activity2);
    } else {
      var _loop = function _loop(interval) {
        var _this$determineDelay3;

        var actions = every == null ? void 0 : every[interval]; // interval could be a `ref` not the actual interval value, let's determine the actual value

        var ms = (_this$determineDelay3 = _this.determineDelay(interval, event)) != null ? _this$determineDelay3 : 0; // create the activity to run for each `every` reaction

        var activity = function activity(_, event) {
          var id = setInterval(function () {
            _this.executeActions(event, actions);
          }, ms);
          return function () {
            return clearInterval(id);
          };
        };

        iterator(activity);
      };

      // every = { 1000: [fn, fn] | fn, [ref]: fn }
      for (var interval in every) {
        _loop(interval);
      }
    }
  });

  _defineProperty(this, "setEvent", function (event) {
    var eventType = (0, _utils2.toEvent)(event).type;
    _this.state.event = eventType === _utils2.INTERNAL_EVENTS.SYNC ? [_this.state.event, _utils2.INTERNAL_EVENTS.SYNC].join(" > ") : eventType;
  });

  _defineProperty(this, "performTransitionSideEffects", function (current, next, event) {
    var _next$target, _next$transition;

    _this.setEvent(event);

    next.target = (_next$target = next.target) != null ? _next$target : _this.state.current;
    var changed = next.target !== _this.state.current;

    var go = function go(next) {
      return changed && next.target;
    };

    if (go(next)) {
      // get explicit exit and implicit "after.exit" actions for current state
      var exitActions = (0, _utils2.toArray)(current == null ? void 0 : current.exit);

      var afterExitActions = _this.afterEventsMap.get(_this.state.current);

      if (afterExitActions) {
        exitActions.push.apply(exitActions, afterExitActions);
      } // call all exit actions for current state


      _this.executeActions(event, exitActions); // cleanup activities for current state


      if (current && _this.hasActivities(current)) {
        _this.stopActivities(_this.state.current);
      }
    } // execute transition actions


    _this.executeActions(event, next == null ? void 0 : (_next$transition = next.transition) == null ? void 0 : _next$transition.actions); // go to next state


    _this.assignState(next.target);

    _this.assignTags(next);

    if (go(next)) {
      var _next$stateNode2, _next$stateNode3, _next$stateNode4, _next$stateNode5;

      // get all entry actions
      var entryActions = (0, _utils2.toArray)((_next$stateNode2 = next.stateNode) == null ? void 0 : _next$stateNode2.entry);

      var afterActions = _this.convertAfterToActions(next.target);

      if ((_next$stateNode3 = next.stateNode) != null && _next$stateNode3.after && afterActions) {
        _this.afterEventsMap.set(next.target, afterActions == null ? void 0 : afterActions.exits);

        entryActions.push.apply(entryActions, afterActions.entries);
      } // execute entry actions for next state


      _this.executeActions(event, entryActions); // execute activities for next state


      var activities = (0, _utils2.toArray)((_next$stateNode4 = next.stateNode) == null ? void 0 : _next$stateNode4.activities); // if `every` is defined, create an activity and append to activities

      _this.createEveryActivities((_next$stateNode5 = next.stateNode) == null ? void 0 : _next$stateNode5.every, function (activity) {
        activities.unshift(activity);
      });

      if (activities.length > 0) {
        _this.executeActivities(event, activities);
      }

      if (next.stateNode && _this.isFinalState(next.stateNode)) {
        _this.state.done = true;
      }
    }
  });

  _defineProperty(this, "checkTransient", function (next, event) {
    var _next$stateNode6;

    if (!((_next$stateNode6 = next.stateNode) != null && _next$stateNode6.always)) return next;
    var dfn = next.stateNode.always;
    var transition = (0, _utils2.toTransition)(dfn, null);

    var _transition = (0, _utils2.isArray)(transition) ? _this.pickTransition(event, transition) : transition;

    if (_transition != null && _transition.target) {
      next = _this.getNextState(event, _transition);
    }

    if (!(_transition != null && _transition.target) && _transition != null && _transition.actions) {
      // execute transient actions
      var cond = _this.determineGuard(_transition.cond) || function () {
        return true;
      };

      if (cond(_this.state.context, event)) {
        _this.executeActions(event, _transition.actions);
      }
    }

    return next;
  });

  _defineProperty(this, "sendParent", function (evt) {
    var _this$parent;

    var event = (0, _utils2.toEvent)(evt);
    event.src = _utils2.INTERNAL_EVENTS.SEND_PARENT;
    (_this$parent = _this.parent) == null ? void 0 : _this$parent.send(event);
  });

  _defineProperty(this, "sendChild", function (evt, to) {
    var event = (0, _utils2.toEvent)(evt);
    var id = typeof to === "function" ? to(_this.state.context) : to;

    var child = _this.children.get(id);

    child == null ? void 0 : child.send(event);
  });

  _defineProperty(this, "stopChild", function (child) {
    if (_this.children.has(child.id)) {
      child.stop();

      _this.children["delete"](child.id);
    }
  });

  _defineProperty(this, "send", function (evt) {
    var event = (0, _utils2.toEvent)(evt);
    var isInit = event.type === _utils2.INTERNAL_EVENTS.INIT;

    var stateNode = _this.getStateConfig(_this.state.current);

    if (isInit) {
      var next = _this.getNextState(event, {
        target: _this.config.initial
      }); //@ts-ignore


      next = _this.checkTransient(next, event);

      _this.performTransitionSideEffects(stateNode, next, event);
    } else {
      _this.transition(stateNode, event);
    }
  });

  _defineProperty(this, "transition", function (stateNode, evt) {
    var _stateNode$on$event$t, _stateNode$on, _this$config$on;

    var event = (0, _utils2.toEvent)(evt);

    if (!stateNode && !_this.config.on) {
      throw new Error("[machine]: state node has no definition");
    }

    var _transition = (_stateNode$on$event$t = stateNode == null ? void 0 : (_stateNode$on = stateNode.on) == null ? void 0 : _stateNode$on[event.type]) != null ? _stateNode$on$event$t : (_this$config$on = _this.config.on) == null ? void 0 : _this$config$on[event.type];

    var transition = (0, _utils2.toTransition)(_transition, _this.state.current);
    if (!transition) return;

    var next = _this.getNextState(event, transition); //@ts-ignore


    next = _this.checkTransient(next, event);

    _this.performTransitionSideEffects(stateNode, next, event);

    return next.stateNode;
  });

  this.options = _options;
  this.config = _config;
  this.id = (_config$id = _config.id) != null ? _config$id : "machine-" + (0, _nanoid.nanoid)();

  var _context = (_config$context = _config.context) != null ? _config$context : {};

  this.context = _context;
  this.state = (0, _utils.proxyWithComputed)({
    current: "",
    prev: "",
    event: "",
    context: _context,
    done: false,
    tags: new Set(),
    hasTag: function hasTag(tag) {
      return this.tags.has(tag);
    },
    matches: function matches(value) {
      return (0, _utils2.isArray)(value) ? value.includes(this.current) : this.current === value;
    }
  }, _extends({}, (0, _utils2.toComputed)(_options == null ? void 0 : _options.computed), {
    nextEvents: function nextEvents(self) {
      var _self$current$on, _config$states, _config$states$self$c, _config$on;

      var stateEvents = (_self$current$on = (_config$states = _config.states) == null ? void 0 : (_config$states$self$c = _config$states[self.current]) == null ? void 0 : _config$states$self$c["on"]) != null ? _self$current$on : {};
      var globalEvents = (_config$on = _config == null ? void 0 : _config.on) != null ? _config$on : {};
      Object.assign(stateEvents, globalEvents);
      return (0, _utils2.keys)(stateEvents).filter(function (event) {
        return event !== _utils2.INTERNAL_EVENTS.SYNC;
      });
    },
    changed: function changed(self) {
      if (self.event === _utils2.INTERNAL_EVENTS.INIT || !self.prev) return false;
      return self.current !== self.prev;
    }
  }));
  if (_options != null && _options.guards) this.guardsMap = _options.guards;
  if (_options != null && _options.actions) this.actionsMap = _options.actions;
  if (_options != null && _options.delays) this.delaysMap = _options.delays;
} // Starts the interpreted machine.
;

exports.Machine = Machine;
//# sourceMappingURL=machine.js.map