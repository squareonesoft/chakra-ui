{"version":3,"sources":["../../src/machine.ts"],"names":["MachineStatus","Machine","config","options","NotStarted","MACHINE_TYPES","MACHINE","Map","status","Running","send","INTERNAL_EVENTS","INIT","Stopped","state","current","event","STOP","context","stopChildren","stopActivities","stopAfterEvents","afterEventsMap","forEach","fns","stop","clear","key","disposables","get","cleanup","set","children","child","parent","src","id","actor","__type","ACTOR","setParent","has","Set","add","target","prev","next","tags","stateNode","listener","newContext","type","states","transitions","transition","pickTransition","getStateConfig","undefined","isTransient","always","hasTarget","activities","every","delay","delaysMap","value","Number","cond","guardsMap","exec","find","t","determineGuard","actions","AFTER","after","entries","exits","toActions","determineDelay","entry","setTimeout","getNextState","performTransitionSideEffects","exit","clearTimeout","push","_transition","picked","action","actionsMap","console","warn","fn","activity","addCleanup","iterator","EVERY","interval","ms","_","setInterval","executeActions","clearInterval","eventType","SYNC","join","setEvent","changed","go","exitActions","afterExitActions","hasActivities","assignState","assignTags","entryActions","afterActions","convertAfterToActions","createEveryActivities","unshift","length","executeActivities","isFinalState","done","dfn","evt","SEND_PARENT","to","isInit","initial","checkTransient","on","Error","hasTag","tag","matches","includes","computed","nextEvents","self","stateEvents","globalEvents","Object","assign","filter","guards","delays"],"mappings":"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","sourcesContent":["/* eslint-disable react/static-property-placement */\nimport { nanoid } from \"nanoid\"\nimport { ref, subscribe } from \"valtio\"\nimport { proxyWithComputed as proxy } from \"valtio/utils\"\nimport { Dict, MaybeArray, StateMachine as S } from \"./types\"\nimport {\n  INTERNAL_EVENTS,\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  keys,\n  MACHINE_TYPES,\n  toArray,\n  toEvent,\n  toTarget,\n  toTransition,\n  toComputed,\n  isGuardHelper,\n} from \"./utils\"\n\nexport enum MachineStatus {\n  NotStarted = \"Not Started\",\n  Running = \"Running\",\n  Stopped = \"Stopped\",\n}\n\n/**\n * Machine is used to create, interpret, and execute finite state machines.\n * It is inspired by XState, State Designer and Robot3.\n */\nexport class Machine<\n  TContext extends Dict,\n  TState extends string,\n  TEvent extends S.EventObject = S.AnyEventObject\n> {\n  status: MachineStatus = MachineStatus.NotStarted\n  state: S.State<TContext>\n  config: S.MachineConfig<TContext, TState, TEvent>\n  options: S.MachineOptions<TContext, TEvent> | undefined\n  context: TContext\n  id: string\n  __type = MACHINE_TYPES.MACHINE\n\n  // Cleanup function map (per state)\n  private disposables = new Map<string, Set<VoidFunction>>()\n  private afterEventsMap = new Map<string, any[]>()\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: Machine<any, any>\n  private children = new Map<string, Machine<any, any>>()\n\n  // A map of gaurd, action, delay implementations\n  private guardsMap?: S.GuardsMap<TContext, TEvent>\n  private actionsMap?: S.ActionsMap<TContext, TEvent>\n  private delaysMap?: S.TimersMap<TContext, TEvent>\n\n  // Let's get started!\n  constructor(\n    config: S.MachineConfig<TContext, TState, TEvent>,\n    options?: S.MachineOptions<TContext, TEvent>,\n  ) {\n    this.options = options\n    this.config = config\n    this.id = config.id ?? `machine-${nanoid()}`\n    const context = config.context ?? ({} as TContext)\n    this.context = context\n    this.state = proxy(\n      {\n        current: \"\",\n        prev: \"\",\n        event: \"\",\n        context,\n        done: false,\n        tags: new Set<string>(),\n        hasTag(tag: string): boolean {\n          return this.tags.has(tag)\n        },\n        matches(value: string | string[]): boolean {\n          return isArray(value)\n            ? value.includes(this.current)\n            : this.current === value\n        },\n      },\n      {\n        ...toComputed(options?.computed),\n        nextEvents(self) {\n          const stateEvents =\n            (config.states as Dict)?.[self.current]?.[\"on\"] ?? {}\n          const globalEvents = config?.on ?? {}\n          Object.assign(stateEvents, globalEvents)\n          return keys(stateEvents).filter(\n            (event) => event !== INTERNAL_EVENTS.SYNC,\n          )\n        },\n        changed(self) {\n          if (self.event === INTERNAL_EVENTS.INIT || !self.prev) return false\n          return self.current !== self.prev\n        },\n      },\n    )\n\n    if (options?.guards) this.guardsMap = options.guards\n    if (options?.actions) this.actionsMap = options.actions\n    if (options?.delays) this.delaysMap = options.delays\n  }\n\n  // Starts the interpreted machine.\n  start = () => {\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) return\n\n    this.status = MachineStatus.Running\n    this.send(INTERNAL_EVENTS.INIT)\n    return this\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    this.state.current = \"\"\n    this.state.event = INTERNAL_EVENTS.STOP\n    if (this.config.context) {\n      this.state.context = this.config.context\n    }\n    // cleanups\n    this.stopChildren()\n    this.stopActivities()\n    this.stopAfterEvents()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopAfterEvents = () => {\n    this.afterEventsMap.forEach((fns) => {\n      fns.forEach((stop) => stop())\n    })\n    this.afterEventsMap.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (key?: string) => {\n    if (key) {\n      this.disposables.get(key)?.forEach((cleanup) => cleanup())\n      this.disposables.delete(key)\n    } else {\n      this.disposables.forEach((set) => {\n        set.forEach((cleanup) => cleanup())\n      })\n      this.disposables.clear()\n    }\n  }\n\n  // Stop and delete spawned children\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  spawn = (src: MachineSrc<any, any>, id = nanoid()) => {\n    const actor = isFunction(src) ? src() : src\n    actor.id = id\n    actor.__type = MACHINE_TYPES.ACTOR\n    actor.setParent(this)\n    this.children.set(id, actor)\n    return ref(actor)\n  }\n\n  private addCleanup = (key: string, cleanup: VoidFunction) => {\n    if (!this.disposables.has(key)) {\n      this.disposables.set(key, new Set([cleanup]))\n    } else {\n      this.disposables.get(key)?.add(cleanup)\n    }\n  }\n\n  private assignState = (target: string) => {\n    this.state.prev = this.state.current\n    this.state.current = target\n  }\n\n  private assignTags = (next: S.StateInfo<TContext, TState, TEvent>) => {\n    this.state.tags = new Set(next.stateNode?.tags ?? [])\n  }\n\n  subscribe = (listener: S.SubscribeFunction<TContext>) => {\n    return subscribe(this.state, () => {\n      this.context = this.state.context\n      listener(this.state)\n    })\n  }\n\n  /**\n   * Used to create a new machine from existing machine\n   * but with modified context.\n   */\n  withContext = (context: Partial<TContext>) => {\n    const newContext = { ...this.config.context, ...context } as TContext\n    return new Machine({ ...this.config, context: newContext }, this.options)\n  }\n\n  withConfig = (config: Partial<S.MachineConfig<TContext, TState, TEvent>>) => {\n    return new Machine({ ...this.config, ...config }, this.options)\n  }\n\n  withOptions = (options: Partial<S.MachineOptions<TContext, TEvent>>) => {\n    return new Machine(this.config, { ...this.options, ...options })\n  }\n\n  private isFinalState = (stateNode: S.StateNode<TContext, TState, TEvent>) => {\n    return stateNode.type === \"final\"\n  }\n\n  private getStateConfig = (state: string) => {\n    if (!state) return\n    type StateConfig = S.StateNode<TContext, TState, TEvent>\n    return (this.config.states as Dict)[state] as StateConfig\n  }\n\n  private getNextState = (\n    event: TEvent,\n    transitions: S.Transitions<TContext, TState, TEvent>,\n  ) => {\n    const transition = this.pickTransition(event, transitions)\n\n    const stateNode = transition\n      ? this.getStateConfig(transition.target ?? this.state.current)\n      : undefined\n\n    const isTransient = !!stateNode?.always\n\n    return {\n      transition,\n      stateNode,\n      hasTarget: !!transition,\n      isTransient,\n      target: transition?.target,\n    }\n  }\n\n  /**\n   * Check if a state has running activities. A state is considering to\n   * have running activity if it defined `activities` or `every`\n   */\n  private hasActivities = (state: S.StateNode<TContext, TState, TEvent>) => {\n    if (!state) return false\n    return state.activities || state.every\n  }\n\n  /**\n   * Delay can be specified as:\n   * - a string (reference to `options.delays`)\n   * - a number (in ms)\n   * - a function that returns a number (in ms)\n   *\n   * Let's resolve this to a number\n   */\n  private determineDelay = (\n    delay: S.Delay<TContext, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    if (typeof delay === \"number\") {\n      return delay\n    }\n\n    if (isFunction(delay)) {\n      return delay(this.state.context, event)\n    }\n\n    if (isString(delay)) {\n      if (this.delaysMap) {\n        const value = this.delaysMap?.[delay]\n        return isFunction(value) ? value(this.state.context, event) : value\n      }\n      return Number(delay)\n    }\n\n    return delay\n  }\n\n  /**\n   * Guards or conditions can be specified as:\n   * - a string (reference to `options.guards`)\n   * - a function that returns a number (in ms)\n   */\n  private determineGuard = (\n    cond: S.Condition<TContext, TEvent> | undefined,\n  ) => {\n    if (isString(cond)) {\n      return this.guardsMap?.[cond]\n    }\n    if (isGuardHelper(cond)) {\n      return cond.exec(this.guardsMap ?? {})\n    }\n    return cond\n  }\n\n  /**\n   * A transition is an object that describes the next state, or/and actions\n   * that should run when an event is sent.\n   *\n   * Transitions can be specified as:\n   * - A single string: \"spinning\"\n   * - An object with `target`, `actions`, or `cond`: { target: \"spinning\", actions: [...], cond: isValid }\n   * - An array of possible transitions. In this case, we'll pick the first matching transition\n   * depending on the `cond` specified\n   */\n  private pickTransition = (\n    event: TEvent,\n    transitions?: S.Transitions<TContext, TState, TEvent>,\n  ): S.TransitionDefinitionWithDelay<TContext, TState, TEvent> | undefined => {\n    type TransitionDfn = S.TransitionDefinition<TContext, TState, TEvent>\n\n    return toArray(transitions).find((t) => {\n      // convert to transition object, if it's a string\n      const transition = toTarget(t) as TransitionDfn\n      // get condition function\n      const cond = this.determineGuard(transition.cond)\n      return (\n        cond?.(this.state.context, event) ??\n        transition.target ??\n        transition.actions\n      )\n    })\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the after into `entry` and `exit` functions and\n   * append them to the normal `entry` and `exit` actions\n   */\n  private convertAfterToActions = (state: string) => {\n    type DelayedTransition = S.TransitionDefinitionWithDelay<\n      TContext,\n      TState,\n      TEvent\n    >\n\n    const event = toEvent(INTERNAL_EVENTS.AFTER) as TEvent\n    const { after } = this.getStateConfig(state) ?? {}\n\n    if (!after) return\n\n    const entries: any[] = []\n    const exits: any[] = []\n\n    const toActions = (transition: DelayedTransition) => {\n      // get the computed delay\n      const delay = this.determineDelay(transition.delay, event) ?? 0\n\n      let id: any\n\n      return {\n        entry: () => {\n          id = setTimeout(() => {\n            const next = this.getNextState(event, transition)\n            const current = this.getStateConfig(this.state.current)\n            if (current) {\n              this.performTransitionSideEffects(current, next, event)\n            }\n          }, delay)\n        },\n        exit: () => {\n          clearTimeout(id)\n        },\n      }\n    }\n\n    if (isArray(after)) {\n      const transition = this.pickTransition(event, after)\n      if (!transition) return\n\n      const t = isString(transition)\n        ? ({ target: transition } as DelayedTransition)\n        : transition\n\n      const { entry, exit } = toActions(t)\n\n      entries.push(entry)\n      exits.push(exit)\n    } else if (isObject(after)) {\n      for (const delay in after) {\n        const transition = after[delay]\n        let _transition: DelayedTransition\n\n        if (isArray(transition)) {\n          const picked = this.pickTransition(event, transition)\n          if (picked) _transition = picked\n        } else if (isString(transition)) {\n          _transition = { target: transition, delay }\n        } else {\n          _transition = { ...transition, delay }\n        }\n\n        //@ts-ignore\n        const { entry, exit } = toActions(_transition)\n        entries.push(entry)\n        exits.push(exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actionsMap`) or actual functions.\n   */\n  private executeActions = (\n    event: TEvent,\n    actions?: S.Actions<TContext, TEvent>,\n  ) => {\n    if (!actions) return\n    actions = toArray(actions)\n    for (const action of actions) {\n      if (isString(action) && !this.actionsMap?.[action]) {\n        console.warn(`${action} not implemented in ${this.id}`)\n      }\n      const fn = isString(action) ? this.actionsMap?.[action] : action\n      fn?.(this.state.context, event)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: S.Activities<TContext, TEvent>,\n  ) => {\n    if (isArray(activities)) {\n      for (const activity of activities) {\n        const cleanup = activity(this.state.context, event)\n        this.addCleanup(this.state.current, cleanup)\n      }\n    } else {\n      const cleanup = activities?.(this.state.context, event)\n      this.addCleanup(this.state.current, cleanup)\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to object transition. Every transitions\n   * can be:\n   * - An array of possible actions to run (we need to pick the first match based on cond)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"],\n    iterator: (activity: S.Activity<TContext, TEvent>) => void,\n  ) => {\n    if (!every) return\n    const event = toEvent(INTERNAL_EVENTS.EVERY) as TEvent\n\n    // every: [{ interval: 2000, actions: [...], cond: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], cond: ... }\n      const picked = toArray(every).find((t) => {\n        t.interval = this.determineDelay(t.interval, event)\n        const cond = t.cond ? this.determineGuard(t.cond) : undefined\n        return cond?.(this.state.context, event) ?? t.interval\n      })\n\n      if (!picked) return\n\n      const ms = this.determineDelay(picked.interval, event) ?? 0\n\n      const activity = (_: TContext, event: TEvent) => {\n        const id = setInterval(() => {\n          this.executeActions(event, picked.actions)\n        }, ms)\n        return () => clearInterval(id)\n      }\n      iterator(activity)\n    } else {\n      // every = { 1000: [fn, fn] | fn, [ref]: fn }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const ms = this.determineDelay(interval, event) ?? 0\n\n        // create the activity to run for each `every` reaction\n        const activity = (_: TContext, event: TEvent) => {\n          const id = setInterval(() => {\n            this.executeActions(event, actions)\n          }, ms)\n          return () => clearInterval(id)\n        }\n        iterator(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent) => {\n    const eventType = toEvent(event).type\n    this.state.event =\n      eventType === INTERNAL_EVENTS.SYNC\n        ? [this.state.event, INTERNAL_EVENTS.SYNC].join(\" > \")\n        : eventType\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performTransitionSideEffects = (\n    current: S.StateNode<TContext, TState, TEvent> | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    this.setEvent(event)\n    next.target = next.target ?? this.state.current\n\n    const changed = next.target !== this.state.current\n    const go = (next: any): next is { target: any } => changed && next.target\n\n    if (go(next)) {\n      // get explicit exit and implicit \"after.exit\" actions for current state\n      const exitActions = toArray(current?.exit)\n      const afterExitActions = this.afterEventsMap.get(this.state.current)\n      if (afterExitActions) {\n        exitActions.push(...afterExitActions)\n      }\n\n      // call all exit actions for current state\n      this.executeActions(event, exitActions)\n\n      // cleanup activities for current state\n      if (current && this.hasActivities(current)) {\n        this.stopActivities(this.state.current)\n      }\n    }\n\n    // execute transition actions\n    this.executeActions(event, next?.transition?.actions)\n\n    // go to next state\n    this.assignState(next.target)\n    this.assignTags(next)\n\n    if (go(next)) {\n      // get all entry actions\n      const entryActions = toArray(next.stateNode?.entry)\n      const afterActions = this.convertAfterToActions(next.target)\n\n      if (next.stateNode?.after && afterActions) {\n        this.afterEventsMap.set(next.target, afterActions?.exits)\n        entryActions.push(...afterActions.entries)\n      }\n\n      // execute entry actions for next state\n      this.executeActions(event, entryActions)\n\n      // execute activities for next state\n      const activities = toArray(next.stateNode?.activities)\n\n      // if `every` is defined, create an activity and append to activities\n      this.createEveryActivities(next.stateNode?.every, (activity) => {\n        activities.unshift(activity)\n      })\n\n      if (activities.length > 0) {\n        this.executeActivities(event, activities)\n      }\n\n      if (next.stateNode && this.isFinalState(next.stateNode)) {\n        this.state.done = true\n      }\n    }\n  }\n\n  /**\n   * Check if the next state is transient and updates the\n   * next state to go to target of transient state.\n   */\n  private checkTransient = (\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    if (!next.stateNode?.always) return next\n\n    type TransitionDfn = S.TransitionDefinition<TContext, TState, TEvent>\n    const dfn = next.stateNode.always\n    const transition = toTransition(dfn, null) as MaybeArray<TransitionDfn>\n\n    const _transition = isArray(transition)\n      ? this.pickTransition(event, transition)\n      : transition\n\n    if (_transition?.target) {\n      next = this.getNextState(event, _transition)\n    }\n\n    if (!_transition?.target && _transition?.actions) {\n      // execute transient actions\n      const cond = this.determineGuard(_transition.cond) || (() => true)\n      if (cond(this.state.context, event)) {\n        this.executeActions(event, _transition.actions)\n      }\n    }\n\n    return next\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  sendParent = (evt: Event) => {\n    const event = toEvent(evt) as S.EventWithSrc\n    event.src = INTERNAL_EVENTS.SEND_PARENT\n    this.parent?.send(event)\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  sendChild = (evt: Event, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = typeof to === \"function\" ? to(this.state.context) : to\n    const child = this.children.get(id)\n    child?.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  stopChild = (child: Machine<any, any>) => {\n    if (this.children.has(child.id)) {\n      child.stop()\n      this.children.delete(child.id)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  send = (evt: string | TEvent) => {\n    const event = toEvent(evt) as TEvent\n    const isInit = event.type === INTERNAL_EVENTS.INIT\n    const stateNode = this.getStateConfig(this.state.current)\n\n    if (isInit) {\n      let next = this.getNextState(event, { target: this.config.initial })\n      //@ts-ignore\n      next = this.checkTransient(next, event)\n      this.performTransitionSideEffects(stateNode, next, event)\n    } else {\n      this.transition(stateNode, event)\n    }\n  }\n\n  transition = (\n    stateNode: S.StateNode<TContext, TState, TEvent> | undefined,\n    evt: TEvent | string,\n  ) => {\n    type TransitionDfn = S.TransitionDefinition<TContext, TState, TEvent>\n\n    const event = toEvent(evt) as TEvent\n\n    if (!stateNode && !this.config.on) {\n      throw new Error(\"[machine]: state node has no definition\")\n    }\n\n    const _transition =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const transition = toTransition(_transition, this.state.current)\n    if (!transition) return\n\n    let next = this.getNextState(event, transition as TransitionDfn)\n    //@ts-ignore\n    next = this.checkTransient(next, event)\n    this.performTransitionSideEffects(stateNode, next, event)\n    return next.stateNode\n  }\n}\n\nexport type MachineSrc<\n  C extends Dict,\n  S extends string,\n  E extends S.EventObject = S.AnyEventObject\n> = Machine<C, S, E> | (() => Machine<C, S, E>)\n"],"file":"machine.js"}